---
id: Lecture_15_Software_Vulnerabilities_and_Exploits
created_date: 01/12/2023
updated_date: 01/12/2023
type: note
links:
  - "[[Memory-Unit-and-MIPS-processors]]"
---
* **üè∑Ô∏èTags** : #Distributed-Systems-and-Security-COMP0133 
# Software Vulnerabilities and Exploits

A **vulnerability** is an input independent bug that can cause a program to complete an operation that deviates from the programmers extent, whereas an **exploit** is an input that triggers a vulnerability in a program. Attackers can use exploits to execute operation without authorisation on a vulnerable host. Vulnerable programs run with some privilege level, giving the attacker power to execute code as some other user.

##### Buffer Overflows

Arrays in C are manipulated using pointers. To write correct code in C, you need to ensure that pointers remain within the intended object.

A typical attack involves entering extremely long data when prompted. The input overflows past the buffer size and corrupts the program memory in such a way that a program contained in the long input is executed.

A unix process contains:
* Fixed size text segment
* Data segment that grows towards higher addresses (Heap)
* Stack, holding local variables, function arguments etc and grows towards the lower addresses.

When calling a function, the return address is written onto the stack frame. If the attacker enters malicious text that is bigger than the input buffer the programmer supplied, when the function returns, if the malicious text overwrites the return address then any code that is at that address will be executed.

For this attack to work, the exact address of the start of the stack allocated frame and the address offset of the return address from the buffer needs to be known. These values depend on the previously called functions before the function with the buffer is called.

The **exact** return address isn't required. At the start of the malicious payload can consist of a large **NOP slide**. This is a long sequence of NOP operations that is placed before the actual malicious code. As long as the return address is somewhere in the NOP slide then the malicious code will be ran.

Typically shell-code is injected as it gives the user access to the device that is running the program:

```c
void main()
{
	char *name[2]
	name[0] = "/bin/sh";
	name[1] = NULL;
	execve(name[0], name, NULL)
	exit(0)
}
```

The `exit(0)` is to prevent any errors being raised if `execve()` fails, so the operator of the machine is less likely to notice the attack. 

The attacker will however need to know the full address of where `"/bin/sh"` is on the target machine, which is difficult to determine.

Both jump and call instructions allow instruction pointer relative addressing rather than absolute addressing. This can be done by editing the compiled shell-code as follows:

* Append a call instruction at the end of the shell instruction that has target of the first instruction of the shell-code.
* Place the bytes "/bin/sh" immediately after the `call` instruction. `call` puts the next instruction onto the stack.
* The first instruction should include a jump to the call instruction.

The vulnerable code is likely to copy the input buffer into a variable and compiled code often has zero bytes, which is used to mark the end of strings. This means in order to carry out the attack the zero bytes of the shell-code should be replaced with bytes that are equivalent to 0 bytes.

It is better to use the safe variations of library calls that do length checking.


#### Format String Vulnerabilities

`printf`-like functions take in input of the form:

```c
printf(char *fmtstr, arg1, arg2, ...)
```

The first argument specifies the number and types of the remaining arguments.

If a program allows a user to give an input that is a format string, the attacker can force `printf`-like function to overwrite memory, allowing the attacker to devise an input with shell-code that overwrites the return address of the function.

The `%n` format string specifier represents the number of bytes written so far up to, but not including, the string specifier. The number of bytes is written into the corresponding argument, which is of type `(int *)`.

`printf`'s caller often allocates the format string buffer on the stack. C pushes parameters onto the stack in right to left order, so the format string pointer will be on the top and the last argument is on the bottom. The implementation of `printf` increments a pointer to point to successive arguments. The pointer is incremented depending on the type of the format string specifier (4 bytes for `%d (int)` etc).

The attacker will construct a format string such that `printf`'s pointer increments all the way to the address of the format string buffer. The format string has the target address to write at the start of the format string and the `%n` at the end of the format string.

The format specifier `%08x` prints an integer as hex, taking up 8 places and padding with leading 0 if needed. This is used to increment the pointer all the way down to the format string buffer. Then when the `%n` is reached, it takes the next argument, which now points to the format string buffer and contains the target address, and overwrites the least significant byte of what is stored at that address with the number of bytes printed in the format string so far.

The number of bytes printed is controlled by the attacker, format specifiers can be used to generate the number of bytes written into memory. This can be done multiple times in the same format string to produce multiple bytes.

# Questions / Thoughts