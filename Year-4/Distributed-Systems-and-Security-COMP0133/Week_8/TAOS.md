---
id: TAOS
created_date: 27/11/2023
updated_date: 27/11/2023
type: note
links: 
---
* **üè∑Ô∏èTags** : #Distributed-Systems-and-Security-COMP0133 
# TAOS

The outline of TAOS is as follows:
* Give every machine a public private key pair.
* When a user `pom` logs into machine $X$, `pom` signs the certificate:
	* `pom` says $X$ speaks for `pom` Which essentially means $X$ is executing `poms` program.

Said machine $X$ can now establish an SSL/TLS session with a server and send the message `pom` says $X$ speaks for `pom` to the server, so the server knows that $X$ can speak for `pom`. The server will need access to the public keys of both $X$ and `pom`, $X$ for the SSL/TLS handshake and `poms` for verifying the certificate.

For further SSH calls (say `pom` ssh into $X$ and then ssh from there into $Y$) $X$ can sign and send the message $X$ says $Y$ can speak for `pom` to $Y$. If $Y$ wants to access a server it then sends a proof outline to the server:
* I'm $Y$
* $X$ says $Y$ can speak for `pom`
* `pom` says $X$ can speak to $Y$

Certificates generated by TAOS are independent of channels, if the channel goes down, the certificate is still valid. Additionally certificates can be chained together.


###### Notation
$$
\begin{align}
\text{A says S}
\end{align}
$$
$A$ supports the statement $S$ (A request or assertion). Says essentially means signature. $A$ signs the statement $S$. The message is (as always) signed with the private key

$$
\begin{align}
A \implies B
\end{align}
$$
$A$ speaks for $B$, if $A$ says $S$ then so does $B$.

A **Channel** is a type of principal through which messages can arrive, for example a TCP connection between two principals.

A **Group** is a set of principals. If $A$ is in group $G$ then $A\implies G$.

$$
\begin{align}
\text{A as R}
\end{align}
$$

A **Role** is a state of authority that a principal adopts. This can be done to reduce its rights.

$$
\begin{align}
A | B
\end{align}
$$
If $\text{A says B says S}$ then we say that A is **quoting** B. $A$ is doing the signing and claiming that it is speaking for $B$.

$$
\begin{align}
\text{A for B}
\end{align}
$$
A acts on behalf of B. A is acting with the authority of B. A for logically means that A is allowed to speak for B.

###### Speaks for Axiom
$$
\begin{align}
\text{if (A speaks for B) and (A says S)}\newline
\text{then (B says S)}
\end{align}
$$

###### Hand of Axiom
$$
\begin{align}
\text{if A says (B speaks for A)} \\
\text{then (B speaks for A)}
\end{align}
$$

###### Delegation Axiom
$$
\begin{align}
\text{if A says (B | A) speaks for (B for A)}\\
\text{then (B | A) speaks for (B for A)}
\end{align}
$$
The delegation axiom allows us to keep track of who is saying what on behalf of who.

So if A says that B speaks for A then B speaks for A.

#### Example

Lets assume that Pom wants to connect to a file server through a workstation. The principals involved are:
* Pom
* The workstation's firmware
* The workstations OS
* The Channel connecting the server and the workstation

At boot the workstation firmware generates a new key pair for the workstation's OS. The key pair for the workstation's firmware is not used so that the workstation OS keys are refreshed after reboot. The firmware uses TAOS to say $\text{Workstation firmware says Workstation speaks for Workstation firmware}$. The workstation firmware is never used directly again.

The server will have an access control list which will have a list of public keys for users who can use the server, as well as an OS field, so only certain operating systems can use the server.

The authentication agent for the firmware:
* Knows the key pair of the workstation OS. (But not the firmware) and
* $\text{(Workstation firmware as OS) says (workstation operating system speaks for (workstation firmware as OS)) }$
We then want the workstation to act on behalf of Pom. So Pom signs with his private key:
$\text{Pom says ((Workstation | Pom) speaks for (Workstation for Pom))}$

TAOS uses symmetric key ciphers to encrypt channels between hosts, which are named according to their symmetric key (i.e. $C_{Pom}$). The key is not derived from any of the host keys. 

When Pom sends a request, the file server knows:
$C_{Pom}\text{ says RQ}$ Where RQ is a request. 

When the workstation connects to the file server, the workstation sends additional certificate:
$\text{(Workstation | Pom) says (Channel Pom speaks for (Workstation | Pom))}$

The axioms can then be used to prove that $(Workstation for Pom) says RQ$


##### Message Authentication with TAOS

`Prin` is the datatype of Principals, whilst `Auth` is a sub-type for `PRIN` representing principals that a process can speak for.

A channel is **secure** if it every message received on it is sent by the same process and a channel is **secret** if every message is received by only one process. Channels are represented with the `Chan` datatype. Transmitting an authenticated message requires a process to send it on a secure channel using `Send(dest: Chan, m:Msg)`. The receiver gets the channel (`GetChan(dest: Address)`) on which the message arrives and also the principal that it received the message from. A `SubChan` is a sub-channel which is retrieved by multiplexing a `Chan`. Each `SubChan` represents a different principal that a process can speak for. The receiver can call the `Receive()` command which will return the tuple `(Chan, Msg)`. To allow multiple messages from different Principals on the same channel TAOS exposes the sub-channel  addressing mechanism to extract the Principal from a given Channel. The receiver will use the `AID` (Authentication Identifier), sent by the receiver, which represents the principal on a given channel, this is done using the `GetPrin(c: Chan, aid: AID)` method. 

##### Authentication and Authorisation

When a message is received, the receiver calls `GetPrin()` to get the Principal of the sender. The `Authenticate(p: Prin)` message is then used to get either a compound principal, representing a role, or a simple name.

The `Check(acl: ACL, p: Prin)` method is then used to determine whether the principal is allowed access. The `ACL` type represents an Access Control List.

###### Managing Principals

Principals can be obtained via:
* Inheritance from a parent process.
* Presenting a login
* Adopting a role
* Delegating rights, or
* Claiming delegated rights.

# Questions / Thoughts