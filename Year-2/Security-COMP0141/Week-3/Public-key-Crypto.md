# Public (Asymmetric) Key Cryptography
`Public Key Encryption` uses a public key to encrypt messages. $pk_u$  is the public key for the user $u$. To send a message to user $a$ you encrypt the message with $pk_a$ and user $a$ will decrypt the message using their secret key, $sk_a$. This means every user will have a public key, stored in the PKI or `public key infrastructure` and a secret key that is kept to themselves these will be created by a `key generator`.


### Conditions
The key generator should be:
* Correct: For every $pk, sk$ pair generated by the key generator, a message encrypted using $pk$, $sk$ must be able to decrypt the message correctly. 
* Secure: ^078369
	* `IND-CCA` (Indistinguishable Chosen Ciphertext Attack) Secure: If an attacker has access to a few decryptions to chosen ciphertexts provided by an `Oracle`, the attacker should not be able to distinguish the encryption of one of them from the encryption of the other.
	* `IND-CPA` (Indistinguishable Chosen Plaintext Attack ) Secure: An attacker that has access to two arbritrarily chosen plaintexts should not be able to distinguish the encryption of one plaintext from the other.

#### Process
* Alice encrypt a message using Bobs public key $pk_b$
* Alice sends the encrypted message to Bob
* Bob decrypts the message using his secret key $sk_b$
en 
The threat model is defined [[An-Introduction-to-Ciphers#Threat Model|here]]

By default, any adversary is assumed to have access to the encryption key (as they have access to everybody's public key).

## (Textbook) RSA Encryption
#### Key Generation
* Randomly pick two large primes $p,q$ ($1024+$ bits)
* set $N = pq$
* pick $e,d$ such that $e$ is small and $e,d$ are coprime ($ed=1\mod{(p-1)(q-1)}$) $e$ can be as small as 3.
* $pk = (N,e)$
* $sk=(N,d)$
* Discard $p$ and $q$
#### Encryption
* Generate cipher text: $c = m^e \mod{N}$ 

#### Decryption
* Decrypt cipher text using $d$ the private key.
*  $m = c^d \mod{N}$

$$
\begin{align}
c^d \mod{N} &= (m^e)^d \mod{N}\\
&= m^{ed} \mod{N}\\
&= m^{1\mod{(p-1)(q-1)}}\mod{N}\\
&= m^{1 mod\phi(N)}\mod{N} \text{ Since } N=pq\\
&= m^{1+k\phi(N)}\mod{N}\\
&= m*(m^{\phi(N)})^k\\
&= m * 1^k\mod{N} \text{ By Euler's theorem}\\
&= m\mod{N}
\end{align}
$$

### Security 
If $N$ could be factored (you know $p$ and $q$) then you could compute $\phi({N})$ meaning you could compute  the private key $d = e^{-1}\mod{(p-1)(q-1)}$ . However factoring $N$ is an intractable problem so it is assumed that attackers cannot do this. So until the technology to factor $N$ comes along, RSA-2048 (where $N$ is a 2048 bit number) is considered secure.

This method is not as secure as actual RSA Encryption as it does not protect users from [[Public-key-Crypto#^078369|IND-CCA attacks]]:
![[Pasted image 20220128192053.png|450]]
Since RSA does not include any randomness it does not protect against [[Public-key-Crypto#^078369|IND-CPA attacks]].

In practice `RSA-OAEP` is used instead.

Compared to symmetric key encryption, the encryption is relatively slow due to the algebraic calculations required.