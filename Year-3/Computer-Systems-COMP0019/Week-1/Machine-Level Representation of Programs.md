### History of Processeors
The machine code that a computer executes is dependant on it's processor. Intel chips are the most popular processors at the moment and are typically referred to as the x86 processor line.  A processor can operate with a certain number of bits - that is to say that an x86-32 processor can operate with 32 bits (each register could store 32 bits of memory).

The first intel processor was the 8086 processor. It operated using 16 bits and had 29K transistors. The i386 was the first processor with a 32 bit architecture and had 275K transistors Next the Pentium 4E introduced a 64 bit architecture, 125M and hyperthreading, allowing multiple computations to be ran on a single processor at once. The core 2 was the first processor with multiple "cores" (essentially multiple processors), which has 291M transistors.

Each processor is designed to be backwards compatible - a 64 bit processor has   all the capabilities a 32 bit processor has.

Transistors increase due to improvements in the engineering methods. Each transistor has a feature size which is the width of the narrowest wires in the transistor. This size reduction over time allows more transistors to fit on a CPU

### Program Compilation

Compilers translate source code, like:

```c
int main(){
	printf("Hello world!");
	return 0;
}
```

into machine code. For C Programs this can be done using the GCC compiler, which first converts the source code into assembly code:

```assembly
0000000000001149 <main>:  
   1149:       f3 0f 1e fa             endbr64    
   114d:       55                      push   %rbp  
   114e:       48 89 e5                mov    %rsp,%rbp  
   1151:       48 8d 05 ac 0e 00 00    lea    0xeac(%rip),%rax        # 2004 <_IO_stdin_used+0x4>  
   1158:       48 89 c7                mov    %rax,%rdi  
   115b:       b8 00 00 00 00          mov    $0x0,%eax  
   1160:       e8 eb fe ff ff          call   1050 <printf@plt>  
   1165:       b8 00 00 00 00          mov    $0x0,%eax  
   116a:       5d                      pop    %rbp  
   116b:       c3                      ret
```

It then invokes the assembler and linker to generate the executable machine code from the assembly code.

Suppose we have two files that we want to compile into a single program:

```bash
gcc -Og -o p p1.c p2.c
```

* -0g: Applies optimizations that keeps the structure of the program to make it easier to understand.
* -o: Specifies the output file.
* gcc: Converts the source code into an executable file.

Compilation is carried out as follows:
* Source code is expanded to include parts of code present in the `.c` files such as `#include` and macros specified with `#define` declarations.
* The compiler converts the source code of the two files into assembly code, namely `p1.s` and `p2.s`.
* The assembler converts the assembly code into object code in files `p1.o` and `p2.o` Object code is similar to pure binary code, just without any references to global value addresses and  references to linkages to other files/library code.
* Lastly the linker merges these object files, along with any library functions, into a single file, `p`.
	* Static linking copies library code into the source code.
	* Dynamic linking makes a reference to any external library code and during runtime the library code is linked. 

The resulting code generated by the compiler depends on the ISA (Instruction Set Architecture) of the processor. 

#### Execution

The machine code tends to be describe the behaviour of the program as if one instruction is being ran at a time, sequentially, However this is not necessarily the case and programs tend to be ran out of order (with some instructions ran concurrently) for optimization purposes but in a way that still produces the same behaviour.

Additionally, virtual addresses are used. While typically, the memory system involves many different hardware memories and OS software, in machine code memory addresses are represented as a large byte array. The virtual addresses are converted to physical addresses by the operating system.

C Programs hide the internal state of the processor for example:
* `%rip`: The program counter.
* Register file: General registers for storage of frequently used data.
* Condition Codes: Stores the status information about most recent arithmetic or logical operation. Typically used for conditional branching instructions.

![[Pasted image 20230111162705.png]]

The "Bytes" section of the above is the hex representation of the assembly instruction to the left.

### Data Format 

The data types used to represent various data types in C:

![[Pasted image 20230111172827.png]] ^9e3ae1

A word is 16 bits or two bytes, due to intel's original processor being a 16 bit one.

Assembly code instructions will have a suffix denoting the size of the operand. For example, `movq` means the `mov` operation is being performed on a quad.

###### Assembly Data Types
* Interger data of 1, 2, 4, or 8 bytes.
	* Data Values or Addresses
* Floating point data of 4,8, or 10 bytes.
* SIMD (Single Instruction Multiple Data) vector data types of 8, 16, 32 or 64 bytes. Essentially a small array that has operations applied to it.
	* This allows for applying an operation on multiple pieces of data.
* Code: Byte sequences encoding series of instructions.
* No aggregate types such as arrays or structure.

### Accessing Data

x86-64 processors have 16 general purpose registers which each store 64 bit values, which can be integers or pointers to other addresses. These registers begin with `%r`. Instructions can operate on registers of different sizes.

![[Pasted image 20230111174018.png]]

Referencing register `%eax` takes the least significant 32 bits of register `%rax`, `%ax` takes the smaller 16 bits, etc. Each register has a specific purpose (shown on the right). Editing the low 32 bits, of any 64 bit register will 0 out the remaining high 32 bits.

### Memory Addressing Modes

Operands can have different forms:
* Immediate - Constant values
* Register -Register values
* Memory - Accessing the memory location according to the computed (effective) address.

![[Pasted image 20230111174615.png]] ^7bfb66

When a register `$rax` is given as an operand the value in the register is taken. If given the operand `($rax)` then the value is the piece of data stored in memory at the address stored in the register. This is known as dereferencing. The scale value can only be 1, 2, 4 or 8. This makes accessing consecutive elements easy since each value represents a different [[Machine-Level Representation of Programs#^9e3ae1|data format]].

##### Problem 3.1
```
%rax = 0x100
0x104 = 0xAB
$0x108 = 0x108
(%rax) = 0xFF
4(%rax) = 0xAB
9(%rax, %rdx) = 0x11
260(%rcx, %rdx) = 0x13
```

### Moving Data

Moving data is done with the `mov` command:
```
movq source dest
```

The `q` suffix stands for quad word and specifies the size of the operand. Other suffixes include:
* `b` - byte
* `w` - word
* `l` - long

You cannot move data from somewhere in memory to somewhere else in memory. The same operand styles as stated [[Machine-Level Representation of Programs#^7bfb66|here]].

### Arithmetic and Logic Operations
The load effective address `leaq` instruction can be used for arithmetic:
```assembly
leaq source destination
```

The `destination` address is set to hold the value of the `source` [[Machine-Level Representation of Programs#^7bfb66|address mode expression]]. Because of this, `leaq` can be used to do arithmetic in the form $x +ky$ where $k \in \set{1,2,4,8}$.

Shift instructions are done with `sal` and `sar` for arithmetic shifts and `shl` and `shr` for logical shifts. A single shift will divide / multiply the value by 2. Arithmetic shifts will retain the sign bit when shifting to the right to ensure the number has the correct sign.

All other instructions are found below:

![[Pasted image 20230117123804.png]]

### Transfer Control
Transfer control includes any instruction that moves the instruction pointer to a different position in memory. This occurs during:
* Conditional Jumps.
* Unconditional Jumps.
* Calling functions


#### Definitions
* Architecture (ISA): The parts of a processor design that one needs to understand for writing correct machine/assembly code.
	* Machine Code: The byte-level programs that a processor executes.
	* Assembly Code: A text representation of a code
* Microarchitecture: Implementation of the architecture that DOESN'T change the ISA of the processor.
